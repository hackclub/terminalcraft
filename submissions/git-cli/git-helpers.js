const inquirer = require('inquirer');
const chalk = require('chalk');
const simpleGit = require('simple-git');
const path = require('path');
const fs = require('fs');
const config = require('./config');
const keyring = require('./keyring');

const SENSITIVE_PATTERNS = [/\.env$/, /.*\.pem$/, /id_rsa/, /.*\.key$/, /^\.secret/, /.*\.cred(s|ential)?s?$/i];
const GITIGNORE_TEMPLATE = `
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-temporary-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.*.local
.env.development
.env.test
.env.production

# Mac files
.DS_Store

# VS Code
.vscode/
`;
// ^^ the greatest .gitignore template ever it got it all covered ig, if not feel free for a PR
// this function checks if a repo url looks like github, gitlab, or bitbucket
function isValidRepoUrl(url) {
  if (!url) return false;
  // Supports github, gitlab, bitbucket via https or ssh, with or without .git suffix
  const regex = /^(https|git)(:\/\/|@)(github\.com|gitlab\.com|bitbucket\.org)[\/:]([^\/:]+)\/(.+?)(\.git)?$/i;
  return regex.test(url);
}
// this regex fn was made by Claude 3.7 Sonnet thingink edition, i have absolutely no idea how it works, but it does work.
// it seems like a bunch of random chars, like how the heck is this supposed to work, blackmagic perhaps?

// this one checks for sensitive files before you commit
async function checkForSensitiveFiles(git) {
  const status = await git.status();
  const stagedFiles = status.staged;

  const sensitiveFilesFound = stagedFiles.filter(file =>
    SENSITIVE_PATTERNS.some(pattern => pattern.test(path.basename(file)))
  );

  if (sensitiveFilesFound.length > 0) {
    console.log(chalk.yellow.bold('\nWarning: Potential sensitive files found in staging area:'));
    sensitiveFilesFound.forEach(file => console.log(chalk.yellow(`  - ${file}`)));

    const { shouldUnstage } = await inquirer.prompt([{
      type: 'confirm',
      name: 'shouldUnstage',
      message: 'Do you want to remove them from this commit?',
      default: true
    }]);

    if (shouldUnstage) {
      await git.reset(sensitiveFilesFound);
      console.log(chalk.green('Sensitive files have been unstaged.'));
    }
  }
}

// set git repo in this or other dir
async function createRepo(options = {}) {
  let { dir } = options;
  if (!dir) {
    const answers = await inquirer.prompt([
      {
        type: 'input',
        name: 'dir',
        message: 'Directory to initialize repo in:',
        default: process.cwd()
      }
    ]);
    dir = answers.dir;
  }
  try {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    const git = simpleGit(dir);
    await git.init();
    console.log(chalk.green('Initialized empty git repository in ' + dir));
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// clone repo to your machine
async function cloneRepo(options = {}) {
  let { repo, dir } = options;

  if (!repo) {
    const answers = await inquirer.prompt([
      { type: 'input', name: 'repo', message: 'Repository URL to clone:' }
    ]);
    repo = answers.repo;
  }

  if (!repo) {
    console.log(chalk.red('Repository URL cannot be empty.'));
    return;
  }

  if (!isValidRepoUrl(repo)) {
    console.log(chalk.red('Invalid repository URL. Please use a valid URL from GitHub, GitLab, or Bitbucket.'));
    return;
  }

  if (!dir) {
    const repoName = path.basename(repo, path.extname(repo));
    const answers = await inquirer.prompt([
      { type: 'input', name: 'dir', message: 'Directory to clone into:', default: repoName }
    ]);
    dir = answers.dir;
  }

  try {
    const git = simpleGit();
    console.log(chalk.blue(`Cloning ${repo}...`));
    await git.clone(repo, dir);
    console.log(chalk.green(`Cloned repository into ${path.resolve(dir)}`));
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// this commits and pushes changes, with auth
async function pushChanges(options = {}) {
  let { dir, msg } = options;

  const questions = [];
  if (!dir) questions.push({ type: 'input', name: 'dir', message: 'Repository directory:', default: process.cwd() });
  if (!msg) questions.push({ type: 'input', name: 'msg', message: 'Commit message:', default: 'Update' });

  if (questions.length > 0) {
    const answers = await inquirer.prompt(questions);
    dir = dir || answers.dir;
    msg = msg || answers.msg;
  }

  try {
    const git = simpleGit(dir);
    let status = await git.status();
    if (status.staged.length === 0) {
      console.log(chalk.yellow('No changes staged for commit. Use "Manage staging area" to add files.'));
      return;
    }

    await checkForSensitiveFiles(git);

    // recheck if sensitive files were unstaged
    status = await git.status();
    if (status.staged.length === 0) {
      console.log(chalk.yellow('Commit aborted. No files are staged after removing sensitive files.'));
      return;
    }

    console.log(chalk.blue('Committing changes...'));
    await git.commit(msg);
    await authenticatedPush(git);
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// pulls, adds, commits, and pushes to keep things in sync
async function syncRepo(options = {}) {
  let { dir } = options;
  if (!dir) {
    const answers = await inquirer.prompt([
      { type: 'input', name: 'dir', message: 'Repository directory:', default: process.cwd() }
    ]);
    dir = answers.dir;
  }
  const git = simpleGit(dir);
  try {
    console.log(chalk.blue('Pulling remote changes...'));
    await git.pull();

    console.log(chalk.blue('Adding all local changes...'));
    await git.add('./*');

    await checkForSensitiveFiles(git);

    let status = await git.status();
    if (status.staged.length > 0) {
      console.log(chalk.blue('Committing local changes...'));
      await git.commit('Automated sync commit');
    } else {
      console.log(chalk.yellow('No local changes to commit.'));
    }

    await authenticatedPush(git);
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// tet github username and token
async function configureCredentials(options = {}) {
  let { username, token } = options;

  if (username && token) {
    config.set('username', username);
    await keyring.setToken(username, token);
    console.log(chalk.green('Credentials stored securely.'));
    return;
  }

  const questions = [];
  if (!username) {
    questions.push({ type: 'input', name: 'username', message: 'GitHub Username:', default: config.get('username') });
  }
  if (!token) {
    questions.push({ type: 'password', name: 'token', message: 'GitHub Personal Access Token (leave blank to keep unchanged):', mask: '*' });
  }

  const answers = await inquirer.prompt(questions);
  const finalUsername = username || answers.username;
  const finalToken = token || answers.token;

  if (finalUsername) {
    config.set('username', finalUsername);
    console.log(chalk.green('Username updated.'));
  }

  if (finalUsername && finalToken) {
    await keyring.setToken(finalUsername, finalToken);
    console.log(chalk.green('Token stored securely in system keyring.'));
  }
}

// this sets or updates the remote origin url
async function setOrigin(options = {}) {
  let { dir, url } = options;
  if (!dir) {
    const answers = await inquirer.prompt([{ type: 'input', name: 'dir', message: 'Repository directory:', default: process.cwd() }]);
    dir = answers.dir;
  }
  try {
    const git = simpleGit(dir);
    const remotes = await git.getRemotes();
    const originExists = remotes.some(remote => remote.name === 'origin');

    let remoteUrl = url;
    if (!remoteUrl) {
      const message = originExists ? 'Origin already exists. Enter new URL to update:' : 'Remote repository URL:';
      const answers = await inquirer.prompt([{ type: 'input', name: 'url', message }]);
      remoteUrl = answers.url;
    }

    if (!remoteUrl) {
      return; // user provided no URL exit.
    }

    if (!isValidRepoUrl(remoteUrl)) {
      console.log(chalk.red('Invalid repository URL. Please use a valid URL from GitHub, GitLab, or Bitbucket.'));
      return;
    }

    if (originExists) {
      await git.remote(['set-url', 'origin', remoteUrl]);
      console.log(chalk.green('Origin URL updated.'));
    } else {
      await git.addRemote('origin', remoteUrl);
      console.log(chalk.green('Remote origin added.'));
    }
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// this function helps you manage the staging area
async function manageStagingArea() {
  const { dir } = await inquirer.prompt([{ type: 'input', name: 'dir', message: 'Repository directory:', default: process.cwd() }]);
  try {
    const git = simpleGit(dir);
    const status = await git.status();

    const unstagedFiles = [
      ...status.not_added.map(f => ({ name: `[Untracked] ${f}`, value: f })),
      ...status.modified.map(f => ({ name: `[Modified]  ${f}`, value: f })),
      ...status.deleted.map(f => ({ name: `[Deleted]   ${f}`, value: f })),
    ];

    if (unstagedFiles.length > 0) {
      const { filesToAdd } = await inquirer.prompt([{
        type: 'checkbox',
        name: 'filesToAdd',
        message: 'Select files to STAGE (add to commit)',
        choices: unstagedFiles,
      }]);
      if (filesToAdd.length > 0) {
        await git.add(filesToAdd);
        console.log(chalk.green('Staged selected files.'));
      }
    } else {
      console.log(chalk.yellow('No unstaged changes to add.'));
    }

    const newStatus = await git.status();
    const stagedFiles = newStatus.staged.map(f => ({ name: `[Staged]    ${f}`, value: f }));

    if (stagedFiles.length > 0) {
      const { filesToUnstage } = await inquirer.prompt([{
        type: 'checkbox',
        name: 'filesToUnstage',
        message: 'Select files to UNSTAGE (remove from commit)',
        choices: stagedFiles,
      }]);
      if (filesToUnstage.length > 0) {
        await git.reset(filesToUnstage);
        console.log(chalk.green('Unstaged selected files.'));
      }
    } else {
      console.log(chalk.yellow('No staged files to unstage.'));
    }
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// this creates a .gitignore file with some good defaults
async function createGitignore(options = {}) {
  let { dir } = options;
  if (!dir) {
    const answers = await inquirer.prompt([
      { type: 'input', name: 'dir', message: 'Directory to create .gitignore in:', default: process.cwd() }
    ]);
    dir = answers.dir;
  }

  const gitignorePath = path.join(dir, '.gitignore');

  if (fs.existsSync(gitignorePath)) {
    const { overwrite } = await inquirer.prompt([{
      type: 'confirm',
      name: 'overwrite',
      message: '.gitignore already exists. overwrite it?',
      default: false
    }]);
    if (!overwrite) {
      console.log(chalk.yellow('Operation cancelled.'));
      return;
    }
  }

  try {
    fs.writeFileSync(gitignorePath, GITIGNORE_TEMPLATE.trim());
    console.log(chalk.green(`Successfully created .gitignore in ${dir}`));
  } catch (e) {
    console.error(chalk.red(`Failed to create .gitignore: ${e.message}`));
  }
}

// this does a push with https auth using your token
async function authenticatedPush(git) {
  const username = config.get('username');
  if (!username) {
    console.log(chalk.red('Username not configured. Please run "Configure credentials" first.'));
    return;
  }
  const token = await keyring.getToken(username);

  if (!token) {
    console.log(chalk.red('Token not found in keyring for this user. Please run "Configure credentials" to set it.'));
    return;
  }

  const remotes = await git.getRemotes(true);
  const origin = remotes.find(r => r.name === 'origin');

  if (!origin) {
    console.log(chalk.red('No remote named "origin" found. Please set it first.'));
    return;
  }

  const originalUrl = origin.refs.push;
  if (!originalUrl.startsWith('https://')) {
    console.log(chalk.red('Authenticated push only supports HTTPS remotes.'));
    console.log(chalk.yellow(`Your remote is: ${originalUrl}`));
    return;
  }

  const authenticatedUrl = originalUrl.replace('https://', `https://${encodeURIComponent(username)}:${encodeURIComponent(token)}@`);

  try {
    const currentBranch = (await git.branch()).current;
    console.log(chalk.blue(`Pushing branch '${currentBranch}'...`));
    await git.push('origin', currentBranch, { '--repo': authenticatedUrl });
    console.log(chalk.green('Push successful!'));
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// this just commits staged changes
async function commitChanges(options = {}) {
  let { dir, msg } = options;

  const questions = [];
  if (!dir) questions.push({ type: 'input', name: 'dir', message: 'Repository directory:', default: process.cwd() });
  if (!msg) questions.push({ type: 'input', name: 'msg', message: 'Commit message:' });

  if (questions.length > 0) {
    const answers = await inquirer.prompt(questions);
    dir = dir || answers.dir;
    msg = msg || answers.msg;
  }

  if (!msg) {
    console.log(chalk.red('Commit message cannot be empty.'));
    return;
  }

  try {
    const git = simpleGit(dir);
    let status = await git.status();
    if (status.staged.length === 0) {
      console.log(chalk.yellow('No changes staged for commit. Use "Manage staging area" to add files.'));
      return;
    }

    await checkForSensitiveFiles(git);

    // recheck if sensitive files were unstaged
    status = await git.status();
    if (status.staged.length === 0) {
      console.log(chalk.yellow('Commit aborted. No files are staged after removing sensitive files.'));
      return;
    }

    console.log(chalk.blue('Committing changes...'));
    await git.commit(msg);
    console.log(chalk.green('Changes committed.'));
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// view diffs
async function viewDiff(options = {}) {
  let { dir, staged } = options;
  if (!dir) {
    const answers = await inquirer.prompt([{ type: 'input', name: 'dir', message: 'Repository directory:', default: process.cwd() }]);
    dir = answers.dir;
  }

  try {
    const git = simpleGit(dir);
    let diff;

    if (staged === undefined) { // interactive mode
      const { diffType } = await inquirer.prompt([{
        type: 'list',
        name: 'diffType',
        message: 'Which diff would you like to see?',
        choices: [
          { name: 'Working directory (unstaged changes)', value: 'working' },
          { name: 'Staged changes', value: 'staged' }
        ]
      }]);
      staged = diffType === 'staged';
    }

    if (staged) {
      diff = await git.diff(['--staged']);
    } else {
      diff = await git.diff();
    }

    if (diff) {
      console.log(diff);
    } else {
      console.log(chalk.green('No changes to show.'));
    }
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// manage git branches
async function manageBranches(options = {}) {
  let { dir } = options;
  if (!dir) {
    const answers = await inquirer.prompt([{ type: 'input', name: 'dir', message: 'Repository directory:', default: process.cwd() }]);
    dir = answers.dir;
  }

  try {
    const git = simpleGit(dir);

    const { action } = await inquirer.prompt([{
      type: 'list',
      name: 'action',
      message: 'What do you want to do with branches?',
      choices: [
        'List branches',
        'Create a new branch',
        'Switch to another branch',
        'Delete a local branch',
        'Cancel'
      ]
    }]);

    const branches = await git.branch();

    switch (action) {
      case 'List branches':
        console.log(chalk.green('Current branch:'), chalk.bold(branches.current));
        console.log(chalk.green('Local branches:'), branches.all.join(', '));
        const remotes = await git.getRemotes(true);
        for (const remote of remotes) {
          console.log(chalk.blue(`\nBranches for remote '${remote.name}':`));
          const remoteBranches = await git.listRemote(['--heads', remote.name]);
          if (remoteBranches) {
            console.log(remoteBranches.split('\n').map(b => b.split('\t')[1]?.replace('refs/heads/', '')).filter(Boolean).join('\n'));
          } else {
            console.log(chalk.yellow('No remote branches found.'));
          }
        }
        break;
      case 'Create a new branch':
        const { newBranchName } = await inquirer.prompt([{ type: 'input', name: 'newBranchName', message: 'Enter new branch name:' }]);
        if (newBranchName) {
          await git.checkoutLocalBranch(newBranchName);
          console.log(chalk.green(`Switched to new branch '${newBranchName}'.`));
        }
        break;
      case 'Switch to another branch':
        const switchableBranches = branches.all.filter(b => b !== branches.current);
        if (switchableBranches.length === 0) {
            console.log(chalk.yellow('No other local branches to switch to.'));
            return;
        }
        const { targetBranch } = await inquirer.prompt([{
          type: 'list',
          name: 'targetBranch',
          message: 'Select branch to switch to:',
          choices: switchableBranches
        }]);
        if (targetBranch) {
          await git.checkout(targetBranch);
          console.log(chalk.green(`Switched to branch '${targetBranch}'.`));
        }
        break;
      case 'Delete a local branch':
        const branchesToDelete = branches.all.filter(b => b !== branches.current);
        if (branchesToDelete.length === 0) {
          console.log(chalk.yellow('No other local branches to delete.'));
          return;
        }
        const { branchToDelete } = await inquirer.prompt([{
          type: 'list',
          name: 'branchToDelete',
          message: 'Select branch to delete:',
          choices: branchesToDelete
        }]);
        if (branchToDelete) {
          const { confirmDelete } = await inquirer.prompt([{ type: 'confirm', name: 'confirmDelete', message: `Are you sure you want to delete branch '${branchToDelete}'?`, default: false }]);
          if (confirmDelete) {
            await git.deleteLocalBranch(branchToDelete);
            console.log(chalk.green(`Deleted local branch '${branchToDelete}'.`));
          }
        }
        break;
      case 'Cancel':
        return;
    }
  } catch (e) {
    console.error(chalk.red(e.message));
  }
}

// rebase current branch
async function rebaseBranch(options = {}) {
  let { dir, branch } = options;
  if (!dir) {
    const answers = await inquirer.prompt([{ type: 'input', name: 'dir', message: 'Repository directory:', default: process.cwd() }]);
    dir = answers.dir;
  }

  try {
    const git = simpleGit(dir);
    const branches = await git.branch();

    if (!branch) {
      const otherBranches = branches.all.filter(b => b !== branches.current);
      if (otherBranches.length === 0) {
        console.log(chalk.yellow('No other branches to rebase onto.'));
        return;
      }
      const answers = await inquirer.prompt([{
        type: 'list',
        name: 'branch',
        message: 'Select branch to rebase onto:',
        choices: otherBranches
      }]);
      branch = answers.branch;
    }

    if (branch) {
      console.log(chalk.blue(`Rebasing current branch onto '${branch}'...`));
      await git.rebase([branch]);
      console.log(chalk.green('Rebase successful.'));
    }
  } catch (e) {
    console.error(chalk.red(`Rebase failed: ${e.message}`));
    console.log(chalk.yellow('You may need to resolve conflicts manually and then run "git rebase --continue".'));
  }
}

module.exports = { createRepo, cloneRepo, pushChanges, syncRepo, configureCredentials, setOrigin, manageStaging: manageStagingArea, createGitignore, commitChanges, viewDiff, manageBranches, rebaseBranch };